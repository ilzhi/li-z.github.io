<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ilz Blog</title>
  <subtitle>coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lizhi.trade/"/>
  <updated>2017-02-23T13:44:11.617Z</updated>
  <id>http://lizhi.trade/</id>
  
  <author>
    <name>李智</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中实现继承的各种姿势</title>
    <link href="http://lizhi.trade/2017/02/21/JavaScript%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>http://lizhi.trade/2017/02/21/JavaScript中实现继承的各种姿势/</id>
    <published>2017-02-21T10:57:53.000Z</published>
    <updated>2017-02-23T13:44:11.617Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的.</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><blockquote>
<p>可以利用原型让一个引用类型继承另一个引用类型的属性和方法;由于每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针,而实例都包含一个指向原型对象的指针.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'super'</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getType() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.type;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'sub'</span>;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.getType()); <span class="comment">// "sub"</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法.但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后.</li>
<li>在通过原型链实现继承时,不能使用对象字面量创建原型方法.因为这样做就会重写原型链.</li>
</ul>
<p><strong>不足:</strong></p>
<ul>
<li>在通过原型链实现继承时,原型实际上会变成另一个类型的实例.于是,原先的实例属性,也就成了现在的原型属性.而包含引用类型值的原型属性会被所有实例共享.</li>
<li>没有办法在不影响所有对象实例的情况下,给超类型的构造函数传递参数.</li>
</ul>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote>
<p>在子类型构造函数的内部调用超类型构造函数,利用apply()或call(),可以在将来创建对象实例的时候执行构造函数.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//继承了SuperType</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>,<span class="string">"lz"</span>);</div><div class="line">	<span class="comment">//为了确保SuperType构造函数不会重写子类型的属性.可以在调用超类型构造函数后，再添加应该在子类型中定义的属性</span></div><div class="line">	<span class="keyword">this</span>.age = <span class="number">22</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance);</div></pre></td></tr></table></figure>
<p><strong>不足</strong></p>
<ul>
<li>方法都在构造函数中定义，因此函数复用就无从谈起了.</li>
<li>在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式.</li>
</ul>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote>
<p>类比使用构造函数模式定义类型时的解决方法（组合构造函数模式与原型模式,继承时的解决方法也类似),即组合原型链继承和借用构造函数,属性由借用构造函数的方式继承,方法由原型链继承.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"green"</span>];</div><div class="line">  &#125;</div><div class="line">  SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="comment">//继承属性</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//继承方法</span></div><div class="line">  SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">  SubType.prototype.constructor = SubType;</div><div class="line">  SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"lz"</span>, <span class="number">18</span>);</div><div class="line">  instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">  <span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'zl'</span>,<span class="number">81</span>);</div><div class="line">  instance2.colors.push(<span class="string">'blue'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(instance1.colors);</div><div class="line">  <span class="built_in">console</span>.log(instance2.colors);</div></pre></td></tr></table></figure>
<ul>
<li>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点</li>
</ul>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote>
<p>原型式继承没有使用严格意义上的构造函数,而是借助原型,基于已有的对象创建新对象,同时还无需创建自定义类型,于是,可以借助这个函数:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">      F.prototype = o;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在 object()函数内部,先创建了一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.从本质上讲, object()对传入其中的对象执行了一次浅复制.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">"LZ"</span>,</div><div class="line">      <span class="attr">friends</span>: [<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>]</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> lz = object(person);</div><div class="line">    <span class="keyword">var</span> zl = object(person);</div><div class="line">    lz.friends.push(<span class="string">"zz"</span>);</div><div class="line">    lz.name = <span class="string">"lz"</span>;</div><div class="line">    zl.friends.push(<span class="string">"ee"</span>);</div><div class="line">    zl.name = <span class="string">"zl"</span>;</div><div class="line">    <span class="built_in">console</span>.log(person.friends);<span class="comment">//["aa", "bb", "cc", "zz", "ee"]</span></div><div class="line">    <span class="built_in">console</span>.log(person.name);<span class="comment">//LZ</span></div><div class="line">    <span class="built_in">console</span>.log(lz); <span class="comment">//F &#123;friends: Array[1], name: "lz"&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>如果想使用这种原型式继承,必须先有一个基础对象.可以把它传递给object(),然后根据具体得到的对象加以修改即可.</li>
<li>在这个例子中,把person传入object函数,然后该函数返回一个新对象,这个新对象将 person 作为原型,所以它的原型中就包含一个基本类型值属性和一个引用类型值属性.这意味着 person.friends 不仅属于 person 所有,而且也会被 anotherPerson 以及 yetAnotherPerson 共享.实际上,这就相当于又创建了 person 对象的两个副本.</li>
<li>ECMAScript 5 通过新增 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a>方法规范化了原型式继承,这个方法接收两个参数,在传入一个参数的情况下, Object.create()与 object()方法的行为相同.</li>
<li>Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line"><span class="attr">name</span>: &#123;</div><div class="line"><span class="attr">value</span>: <span class="string">"Greg"</span></div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></div></pre></td></tr></table></figure>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote>
<p>寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该<br>函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(origin);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="string">'Hi'</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"LZ"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>]</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> lz = createAnother(person);</div><div class="line">  lz.sayHi();</div></pre></td></tr></table></figure>
<ul>
<li>这个例子中的代码基于 person 返回了一个新对象——anotherPerson.新对象不仅具有 person<br>的所有属性和方法，而且还有自己的 sayHi()方法</li>
<li>使用寄生式继承来为对象添加函数,会由于不能做到函数复用而降低效率.这一点与构造函数模式类似.</li>
</ul>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,supType</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(supType.prototype);</div><div class="line">    prototype.constructor = subType;</div><div class="line">    subType.prototype = prototype;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>有了上面这个函数,就可以不必为了指定子类型的原型而调用超类型的构造函数.而后通过借用构造函数实现设置属性.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</div><div class="line">  &#125;</div><div class="line">  SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  inheritPrototype(SubType,SuperType);</div><div class="line">  SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> lz = <span class="keyword">new</span> SubType(<span class="string">"lz"</span>,<span class="number">18</span>);</div><div class="line">  <span class="built_in">console</span>.log(lz);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的.&lt;/p&gt;
&lt;h2 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="学习总结" scheme="http://lizhi.trade/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://lizhi.trade/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BFC布局 学习总结</title>
    <link href="http://lizhi.trade/2017/02/20/BFC%E5%B8%83%E5%B1%80-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://lizhi.trade/2017/02/20/BFC布局-学习总结/</id>
    <published>2017-02-20T13:38:49.000Z</published>
    <updated>2017-02-22T08:16:16.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-w3c规范中的BFC定义："><a href="#一-w3c规范中的BFC定义：" class="headerlink" title="一. w3c规范中的BFC定义："></a>一. w3c规范中的BFC定义：</h2><p>“浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>
<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>
<p>也就是说BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响）。并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 由这段定义，我们可以得出：</p>
<h3 id="1-哪些元素会生成BFC："><a href="#1-哪些元素会生成BFC：" class="headerlink" title="1. 哪些元素会生成BFC："></a>1. 哪些元素会生成BFC：</h3><ul>
<li>根元素(整个页面就是一个大的BFC)；</li>
<li>float为 left | right；</li>
<li>overflow为 hidden | auto | scroll；</li>
<li>display为 inline-block | table-cell | table-caption | flex | inline-flex；</li>
<li>position为 absolute | fixed；<h3 id="2-BFC的布局规则："><a href="#2-BFC的布局规则：" class="headerlink" title="2. BFC的布局规则："></a>2. BFC的布局规则：</h3></li>
<li>每一个BFC盒子会在垂直方向一个接一个地排列；</li>
<li>两个BFC盒子之间的垂直的间隙是由他们的margin 值所决定的。属于同一个BFC的两个相邻盒子的垂直方向的margin会重叠；</li>
<li>每一个BFC盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）； 4.计算BFC的高度时，浮动元素也参与计算；</li>
<li>不与外部浮动元素重叠；</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响；<h2 id="二-BFC的应用实例"><a href="#二-BFC的应用实例" class="headerlink" title="二. BFC的应用实例"></a>二. BFC的应用实例</h2></li>
</ul>
<h3 id="1-自适应两栏布局"><a href="#1-自适应两栏布局" class="headerlink" title="1. 自适应两栏布局"></a>1. 自适应两栏布局</h3><h3 id="2-清除内部浮动"><a href="#2-清除内部浮动" class="headerlink" title="2. 清除内部浮动"></a>2. 清除内部浮动</h3><h3 id="3-防止垂直margin重叠"><a href="#3-防止垂直margin重叠" class="headerlink" title="3. 防止垂直margin重叠"></a>3. 防止垂直margin重叠</h3><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p>
<p><strong>折叠的结果：</strong></p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值；</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和；</li>
</ul>
<h3 id="产生折叠的必备条件："><a href="#产生折叠的必备条件：" class="headerlink" title="产生折叠的必备条件："></a>产生折叠的必备条件：</h3><ul>
<li>margin必须是邻接的，没有padding和border将他们分隔开；</li>
<li>必须是处于常规文档流（非float和绝对定位）的块级元素，并且处于同一个BFC当中；</li>
</ul>
<h3 id="产生折叠的常见情况："><a href="#产生折叠的常见情况：" class="headerlink" title="产生折叠的常见情况："></a>产生折叠的常见情况：</h3><ul>
<li>元素的margin-top与其第一个常规文档流的子元素的margin-top；</li>
<li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top；</li>
<li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom；</li>
<li>高度为0且不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom；</li>
</ul>
<h3 id="浮动和绝对定位不与任何元素产生-margin-折叠："><a href="#浮动和绝对定位不与任何元素产生-margin-折叠：" class="headerlink" title="浮动和绝对定位不与任何元素产生 margin 折叠："></a>浮动和绝对定位不与任何元素产生 margin 折叠：</h3><p>原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠；</p>
<p>因此可以通过使元素成为BFC而避免margin折叠。BFC提供了一个独立布局的环境，每个BFC都遵守同一套布局规则。例如，在同一个BFC内，盒子会一个挨着一个的排，相邻盒子的间距是由margin决定且垂直方向的margin会重叠。而float和clear float也只对同一个BFC内的元素有效；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实以上的几个例子都体现了BFC布局规则第六条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响。<br>因此， 当BFC外部存在浮动时，外部元素不会影响BFC内部的布局，BFC会通过变窄，而不与浮动有重叠；同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度和margin值，因此可以避免margin重叠和闭合浮动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-w3c规范中的BFC定义：&quot;&gt;&lt;a href=&quot;#一-w3c规范中的BFC定义：&quot; class=&quot;headerlink&quot; title=&quot;一. w3c规范中的BFC定义：&quot;&gt;&lt;/a&gt;一. w3c规范中的BFC定义：&lt;/h2&gt;&lt;p&gt;“浮动元素和绝对定位元素，非块级
    
    </summary>
    
      <category term="学习总结" scheme="http://lizhi.trade/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="布局" scheme="http://lizhi.trade/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>
