<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ilz Blog</title>
  <subtitle>coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://li-z.github.io/"/>
  <updated>2017-02-21T11:48:56.301Z</updated>
  <id>https://li-z.github.io/</id>
  
  <author>
    <name>李智</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中实现继承的各种姿势</title>
    <link href="https://li-z.github.io/2017/02/21/JavaScript%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://li-z.github.io/2017/02/21/JavaScript中实现继承的各种姿势/</id>
    <published>2017-02-21T10:57:53.000Z</published>
    <updated>2017-02-21T11:48:56.301Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的.</p>
<h2 id="一-原型链继承"><a href="#一-原型链继承" class="headerlink" title="一.原型链继承"></a>一.原型链继承</h2><p>可以利用原型让一个引用类型继承另一个引用类型的属性和方法;由于每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针,而实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'super'</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getType() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.type;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'sub'</span>;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(sub.getType()); <span class="comment">// "sub"</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法.但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后.</li>
<li>在通过原型链实现继承时,不能使用对象字面量创建原型方法.因为这样做就会重写原型链。</li>
</ul>
<p><strong>不足:</strong></p>
<ul>
<li>在通过原型链实现继承时,原型实际上会变成另一个类型的实例.于是,原先的实例属性,也就成了现在的原型属性.而包含引用类型值的原型属性会被所有实例共享.</li>
<li>没有办法在不影响所有对象实例的情况下,给超类型的构造函数传递参数</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的.&lt;/p&gt;
&lt;h2 id=&quot;一-原型链继承&quot;&gt;&lt;a href=&quot;#一-原型链继承&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://li-z.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BFC布局 学习总结</title>
    <link href="https://li-z.github.io/2017/02/20/BFC%E5%B8%83%E5%B1%80-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://li-z.github.io/2017/02/20/BFC布局-学习总结/</id>
    <published>2017-02-20T13:38:49.000Z</published>
    <updated>2017-02-20T14:04:13.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-w3c规范中的BFC定义："><a href="#一-w3c规范中的BFC定义：" class="headerlink" title="一. w3c规范中的BFC定义："></a>一. w3c规范中的BFC定义：</h2><p>“浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>
<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>
<p>也就是说BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响）。并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 由这段定义，我们可以得出：</p>
<h3 id="1-哪些元素会生成BFC："><a href="#1-哪些元素会生成BFC：" class="headerlink" title="1. 哪些元素会生成BFC："></a>1. 哪些元素会生成BFC：</h3><ul>
<li>根元素(整个页面就是一个大的BFC)；</li>
<li>float为 left | right；</li>
<li>overflow为 hidden | auto | scroll；</li>
<li>display为 inline-block | table-cell | table-caption | flex | inline-flex；</li>
<li>position为 absolute | fixed；<h3 id="2-BFC的布局规则："><a href="#2-BFC的布局规则：" class="headerlink" title="2. BFC的布局规则："></a>2. BFC的布局规则：</h3></li>
<li>每一个BFC盒子会在垂直方向一个接一个地排列；</li>
<li>两个BFC盒子之间的垂直的间隙是由他们的margin 值所决定的。属于同一个BFC的两个相邻盒子的垂直方向的margin会重叠；</li>
<li>每一个BFC盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）； 4.计算BFC的高度时，浮动元素也参与计算；</li>
<li>不与外部浮动元素重叠；</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响；<h2 id="二-BFC的应用实例"><a href="#二-BFC的应用实例" class="headerlink" title="二. BFC的应用实例"></a>二. BFC的应用实例</h2></li>
</ul>
<h3 id="1-自适应两栏布局"><a href="#1-自适应两栏布局" class="headerlink" title="1. 自适应两栏布局"></a>1. 自适应两栏布局</h3><h3 id="2-清除内部浮动"><a href="#2-清除内部浮动" class="headerlink" title="2. 清除内部浮动"></a>2. 清除内部浮动</h3><h3 id="3-防止垂直margin重叠"><a href="#3-防止垂直margin重叠" class="headerlink" title="3. 防止垂直margin重叠"></a>3. 防止垂直margin重叠</h3><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p>
<p><strong>折叠的结果：</strong></p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值；</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和；</li>
</ul>
<h3 id="产生折叠的必备条件："><a href="#产生折叠的必备条件：" class="headerlink" title="产生折叠的必备条件："></a>产生折叠的必备条件：</h3><ul>
<li>margin必须是邻接的，没有padding和border将他们分隔开；</li>
<li>必须是处于常规文档流（非float和绝对定位）的块级元素，并且处于同一个BFC当中；</li>
</ul>
<h3 id="产生折叠的常见情况："><a href="#产生折叠的常见情况：" class="headerlink" title="产生折叠的常见情况："></a>产生折叠的常见情况：</h3><ul>
<li>元素的margin-top与其第一个常规文档流的子元素的margin-top；</li>
<li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top；</li>
<li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom；</li>
<li>高度为0且不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom；</li>
</ul>
<h3 id="浮动和绝对定位不与任何元素产生-margin-折叠："><a href="#浮动和绝对定位不与任何元素产生-margin-折叠：" class="headerlink" title="浮动和绝对定位不与任何元素产生 margin 折叠："></a>浮动和绝对定位不与任何元素产生 margin 折叠：</h3><p>原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠；</p>
<p>因此可以通过使元素成为BFC而避免margin折叠。BFC提供了一个独立布局的环境，每个BFC都遵守同一套布局规则。例如，在同一个BFC内，盒子会一个挨着一个的排，相邻盒子的间距是由margin决定且垂直方向的margin会重叠。而float和clear float也只对同一个BFC内的元素有效；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实以上的几个例子都体现了BFC布局规则第六条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响。<br>因此， 当BFC外部存在浮动时，外部元素不会影响BFC内部的布局，BFC会通过变窄，而不与浮动有重叠；同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度和margin值，因此可以避免margin重叠和闭合浮动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-w3c规范中的BFC定义：&quot;&gt;&lt;a href=&quot;#一-w3c规范中的BFC定义：&quot; class=&quot;headerlink&quot; title=&quot;一. w3c规范中的BFC定义：&quot;&gt;&lt;/a&gt;一. w3c规范中的BFC定义：&lt;/h2&gt;&lt;p&gt;“浮动元素和绝对定位元素，非块级
    
    </summary>
    
    
      <category term="布局" scheme="https://li-z.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>
