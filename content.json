{"meta":{"title":"ilz Blog","subtitle":null,"description":"李智的个人博客","author":"李智","url":"http://lizhi.trade"},"pages":[{"title":"categories","date":"2017-02-22T08:58:12.000Z","updated":"2017-02-22T08:58:29.119Z","comments":true,"path":"categories/index.html","permalink":"http://lizhi.trade/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-22T08:56:55.000Z","updated":"2017-02-22T08:57:42.748Z","comments":true,"path":"tags/index.html","permalink":"http://lizhi.trade/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript冷门知识点","slug":"JavaScript冷门知识点","date":"2016-03-13T13:05:38.000Z","updated":"2017-05-06T11:03:51.166Z","comments":true,"path":"2016/03/13/JavaScript冷门知识点/","link":"","permalink":"http://lizhi.trade/2016/03/13/JavaScript冷门知识点/","excerpt":"","text":"parseInt 可以接收两个参数 string, radix(基数)第二个参数表示以几进制来表示第一个参数值,该值介于 2 ~ 36 之间。如果是0,则忽略此值。 例: 123parseInt('1', 0); =&gt; 1parseInt('2', 1); =&gt; NaNparseInt('3', 2); =&gt; NaN 在JS中,能正确计算且不失精度的最大整数是Math.pow(2, 53) == 9007199254740992,最大值加一还是最大值例,如下循环不会停止1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); JS中允许存在有空隙的数组,称之为稀疏数组例: 1234567var arr = [1,2,3];arr[100]=1;console.log(10 in arr);console.log(arr.length);arr.forEach(function(x)&#123; console.log(x);&#125;); 输出为: 123false1011 2 3 1 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接.例: 12345'5' + 3 === '53'5 + '3' === '53'5 - '3' === 2'5' - 3 === 2'5' - '3' === 2 JS中1.1, 1., .1 都是合法的数字例: 1233.toString() =&gt; error3..toString() =&gt; '3'3...toString() =&gt; error 数组在比较大小的时候按照值的顺序比较例: 1234567var a = [1, 2, 3], b = [1, 2, 4], c = [2]a &gt; b =&gt; falsea &lt; b =&gt; truea &gt; c =&gt; falsea &lt; c =&gt; true function的 length 属性就是函数的参数个数12Function.length == 1 //(奇葩)new Function().length == 0 Math.min VS Math.max1234Math.min() == InfinityMath.max() == -Infinity//由于这两个奇葩结果,故:Math.min() &gt; Math.max() == true 函数里的参数已经声明了例: 123456789101112131415function foo(a) &#123; var a; return a;&#125;function bar(a) &#123; var a = 'bye'; return a;&#125;//a作为参数其实已经声明了,故第一个函数就等价于var a = 'hello';var a;//第二个函数就等价于var a = 'hello';var a = 'bye'[foo('hello'), bar('hello')] =&gt; ['hello', 'bye'] 原型对象 Object.prototype =&gt; {} Array.prototype =&gt; [] Function.prototype =&gt; function(){} 更简洁的交换两个值: a= [b, b=a][0];","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"HTTP","slug":"HTTP","date":"2015-09-01T14:39:47.000Z","updated":"2017-05-06T11:03:37.995Z","comments":true,"path":"2015/09/01/HTTP/","link":"","permalink":"http://lizhi.trade/2015/09/01/HTTP/","excerpt":"","text":"HTTP协议简介当我们在浏览器地址栏输入lizhi.trade/index.html时,浏览器会先查找和lizhi.trade相关联的服务器地址,然后尝试连接80端口建立TCP连接,其中80端口是HTTP的默认通信端口.如果服务器接收了该请求,浏览器就会默认发送如下内容. GET /index.html HTTP/1.1Host: lizhi.tradeUser-Agent: Your brower’s name 然后服务器后返回如下响应 HTTP/1.1 200 OKContent-Length: 85214Content-Type: text/htmlLast-Modified: Web, 08 Apr2088 10:10:10 GMT &lt;!document html&gt;….. 浏览器会去除响应行的空行,并将剩下部分作为HTML文档展示","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://lizhi.trade/tags/网络/"}]},{"title":"闭包","slug":"闭包","date":"2015-08-12T13:46:37.000Z","updated":"2017-05-06T11:03:28.575Z","comments":true,"path":"2015/08/12/闭包/","link":"","permalink":"http://lizhi.trade/2015/08/12/闭包/","excerpt":"闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点 一：变量的作用域 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。","text":"闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点 一：变量的作用域 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。 123456789101112var a = 1; var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; alert ( b ); // 输出： 2 alert ( a ); // 输出： 1 &#125; func2(); alert ( c ); // 输出： Uncaught ReferenceError: c is not defined &#125;;func1(); 注意：在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的 二：变量的生存周期 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。 但是因为有闭包的存在却产生了很多奇妙的事情，小伙伴们看下面的情形： 1：假设页面上有 5 个div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出0，点击第 2 个 div 时弹出 1，以此类推，你会怎么做呢？ 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; nodes[ i ].onclick = function()&#123; alert ( i ); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你是不是这么想的？嗯哼~ 厉害了，不过错了，啦啦啦， 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候， for 循环早已结束，此时变量 i 的值已经是5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 那怎么办呢？闭包呀，吃包子喽！ 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)( i )&#125;; 三：闭包的更多形式和作用小闭包形式： 1.()() 2.;()() 3.+()() 4.-()() 目的：全局变量私有化 优点： 1.不污染全局变量 2.内部的临时变量执行完毕都会释放，不会占据内存 3.避免使用全局变量 4.更新复杂变量 1.封装变量 计算乘积 1234567891011121314var mult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache )&#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 小伙伴们可看出什么猫腻？对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以像上面那样加入缓存机制来提高这个函数的性能，是不是很机智呢？ 补充点 1234567891011var Type = &#123;&#125;; for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; )&#123;//i++到3的时候type为undefined，结束循环 (function( type )&#123; Type[ 'is' + type ] = function( obj )&#123; return Object.prototype.toString.call( obj ) === '[object '+ type +']'; &#125; &#125;)( type ) &#125;; console.log(Type.isArray([])); console.log(Type.isString(\"str\")); console.log(undefined == false);//false 反正我觉得很好玩，哈哈。 2.延续局部变量的寿命，并读取 引用循环变量，如下所示： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 小伙伴们看这个有什么感触么？调用f1,f2,f3会有什么结果呢？是的，结果往往那么不如人意~~~ f1(); // 16 f2(); // 16 f3(); // 16 Why?原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用，那么又要小包子上场了方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 img 对象经常用于进行数据上报，如下所示： 12345var report = function( src )&#123; var img = new Image(); img.src = src;&#125;;report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说， report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src;&#125;&#125;)(); 3.高级排他123456789101112131415window.onload = function()&#123; var ul = document.getElementById('ul'); var lis = ul.children; var lastOne = 0; for(var i =0; i &lt; lis.length;i++)&#123; (function (index) &#123; lis[i].onmouseover = function () &#123; lis[lastOne].className = ''; this.className = 'current'; lastOne = index &#125; &#125;)(i) &#125;&#125; 每次移动把之前的样式清除，再把当前的设置样式，再次重置初始值。此处还要注意js执行任务的顺序 4.函数节流 使用场景 window.onresize 事件。 我们给 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在 window.onresize 事件函数里有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove 事件。 如果我们给一个 div 节点绑定了拖曳事件（主要是 mousemove） ，当div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。 上传进度。 微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不需要如此频繁地去提示用户 第一种 1234567891011121314151617181920212223242526function throttle(fn, interval) &#123; var timeoutID = null, //保存需要被延迟执行的函数引用 firstTime = true; // 是否是第一次调用 return function () &#123; var self = this; //保存函数的运行环境 console.log(self); var args = arguments; if (firstTime) &#123;// 如果是第一次调用，不需延迟执行 fn.apply(this, args); firstTime = false return; &#125; if (timeoutID) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return; &#125; timeoutID = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timeoutID); timeoutID = null; fn.apply(self, args) &#125;, interval || 500); &#125; &#125; // 这里的意思是window对象上的方法onresize的值是throttle的返回值，所以返回值里面的this指向的是window这个对象，如果是div，onmousemove的话那this就是指向的div了，但是因为闭包返回的函数中的this指向window，所以为了保证this一直是window才用self保存了this从而保存了throttle返回函数的运行环境 window.onresize = throttle(function () &#123; console.log(1); &#125;, 500); 四：闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达 闭包方式 12345678910var extent = function()&#123; var value = 0; return &#123; call: function()&#123; value++; console.log( value ); &#125; &#125;&#125;;var extent = extent(); 面向对象方式 1234567891011var Extent = function()&#123; this.value = 0;&#125;;Extent.prototype.call = function()&#123; this.value++; console.log( this.value );&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 五：用闭包实现命令模式 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来； 在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中。 面向对象版本 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;body&gt;&lt;button id=\"execute\"&gt;点击我执行命令&lt;/button&gt;&lt;button id=\"undo\"&gt;点击我执行命令&lt;/button&gt;&lt;script&gt; var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var OpenTvCommand = function( receiver )&#123; this.receiver = receiver; &#125;; OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机 &#125;; OpenTvCommand.prototype.undo = function()&#123; this.receiver.close(); // 撤销命令，关闭电视机 &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( new OpenTvCommand( Tv ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包版本 1234567891011121314151617181920212223242526272829var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var createCommand = function( receiver )&#123; var execute = function()&#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function()&#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125; &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( createCommand( Tv ) ); 六：闭包与内存管理 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。 使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。 在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 ok，收工！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"this","slug":"this","date":"2015-08-02T13:57:53.000Z","updated":"2017-05-06T11:05:02.466Z","comments":true,"path":"2015/08/02/this/","link":"","permalink":"http://lizhi.trade/2015/08/02/this/","excerpt":"this是Javascript语言的一个关键字 使用场景注意点：在绝大多数情况下，函数的调用方式决定了this的值。this不能在执行期间被赋值，在每次函数被调用时this的值也可能会不同","text":"this是Javascript语言的一个关键字 使用场景注意点：在绝大多数情况下，函数的调用方式决定了this的值。this不能在执行期间被赋值，在每次函数被调用时this的值也可能会不同 全局环境 在全局运行上下文（全局环境）中（在任何函数体外部），this指代全局对象，无论是否在严格模式下 1234// 在浏览器中，全局对象为 window 对象：console.log(this === window); // truethis.a = 37;console.log(window.a); // 37 函数上下文 在函数内部，this的值取决于函数是如何调用的。 1. 直接调用时的this 因为下面的代码不是在严格模式下执行，并且this的值不会在函数执行时被设置，此时的this的值会默认设置为全局对象 1234function f1()&#123; return this;&#125;f1() === window; // true 然而，在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined 12345function f2()&#123; \"use strict\"; // 这里是严格模式 return this;&#125;f2() === undefined; // true 注意：在严格模式下，如果this未被执行的上下文环境定义，那么它将会默认为undefined。 2. 对象方法中的this 当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象. 1234567var o = &#123;prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // logs 37 注意，在何处或者如何定义调用函数完全不会影响到this的行为,this的值只与函数作为对象的成员被调用有关系 3. 构造函数中的this 当一个函数被当做构造函数来调用的时候（首字母大写，与new一起使用），他的this与即将创建的新对象绑定。 12345function C2()&#123; this.a = 37;&#125;o = new C2();console.log(o.a); // logs 37 但是要小心下面的情况 123456function C2()&#123; this.a = 37; return &#123;a:38&#125;;&#125;o = new C2();console.log(o.a); // logs 38 注意：当构造函数返回一个引用类型的时候，与this绑定的默认对象被取消，也就是说返回的值会覆盖原先的新对象 4. call和apply中的this 当一个函数的函数体内部使用了this，然后通过所有的函数都继承了Function对象的原型上的call()和apply()方法调用的时候可以改变this的指向为call和apply方法的第一个参数，如下： 123456789 var x = 0; function test(y,z)&#123; console.log(this.x + y + z); &#125; var obj = &#123; x:3 &#125; test.call(obj,4,5)//test.apply(obj,[4,5]) 注意点：在使用call和apply的时候如果第一个参数传递的不是一个对象，那么JavaScript会在内部使用ToObject将其转换为对象，比如原始值是7的话，内部就会通过new Number(7)来把他转换为一个对象，如下： 1234function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;bar.call(7); // [object Number] 5. bind中的this 如果调用fn.bind(obj)方法的话会创建一个和fn有相同函数体和作用域的新函数，但是这个新函数的this被绑定为了第一个参数obj，而且不管他是怎么调用 1234567function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:\"azerty\"&#125;);console.log(g());//azertyvar o = &#123;a:37, f:f, g:g&#125;;console.log(o.f(), o.g()); //37 azerty 扩充：实现bind 12345678910111213141516171819 Function.prototype.bind = function () &#123; var that = this;// 绑定时候传入的参数 var argu = [].slice.call(arguments);// 需要固定已经传入的参数 var param = argu.slice(1)// 返回的新函数 return function () &#123; that.apply(argu[0],param.concat([].slice.call(arguments))) &#125; &#125; var obj =&#123; name:'ll', show: function (a,b,c,d,e,f) &#123; console.log([a,b,c,d,e,f]); &#125; &#125; var w = obj.show.bind(obj,1,2,3,4); w(5,6,7) 6. DOM事件处理函数中的this 当函数被用作事件处理函数时候，this指向的是触发事件的元素，在一些不是用addEventListener动态添加事件的浏览器中不遵守这个约定 12345678910111213// 被调用时，将关联的元素变成蓝色function bluify(e)&#123; console.log(this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象是为 true console.log(this === e.target); this.style.backgroundColor = '#A5D9F3';&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('div');// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for(var i=0 ; i&lt;elements.length ; i++)&#123; elements[i].addEventListener('click', bluify, false);&#125; 7. 定时器中的this 定时器中回调函数里面的this指向全局window 8. this的备份 当使用多层this时候，为了访问正确的this我们需要对正确的this进行备份，以便后来使用 1234567891011var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 是不是和你想要的不太一样呢？你或许更想要下面这样的呢 123456789101112 var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 以上的代码中用变量that保存了函数外部的this，然后在函数内部使用that就不会发生this指向错乱的情况了 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部的this指向的还是window 123456789101112var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 解决方案一：this的备份 12345678910111213var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+' '+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 解决方案二：将this当作foreach方法的第二个参数，固定它的运行环境。 123456789101112var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 9. Node中的this 在Node中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"JavaScript中实现继承的各种姿势","slug":"JavaScript中实现继承的各种姿势","date":"2015-07-01T14:57:53.000Z","updated":"2017-05-06T11:04:51.730Z","comments":true,"path":"2015/07/01/JavaScript中实现继承的各种姿势/","link":"","permalink":"http://lizhi.trade/2015/07/01/JavaScript中实现继承的各种姿势/","excerpt":"","text":"JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的. 原型链继承 可以利用原型让一个引用类型继承另一个引用类型的属性和方法;由于每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针,而实例都包含一个指向原型对象的指针. 123456789101112function SuperType() &#123; this.type = 'super';&#125;SuperType.prototype.getType() &#123; return this.type;&#125;function SubType() &#123; this.type = 'sub';&#125;SubType.prototype = new SuperType();var instance = new SubType();console.log(instance.getType()); // \"sub\" 注意: 子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法.但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后. 在通过原型链实现继承时,不能使用对象字面量创建原型方法.因为这样做就会重写原型链. 不足: 在通过原型链实现继承时,原型实际上会变成另一个类型的实例.于是,原先的实例属性,也就成了现在的原型属性.而包含引用类型值的原型属性会被所有实例共享. 没有办法在不影响所有对象实例的情况下,给超类型的构造函数传递参数. 借用构造函数 在子类型构造函数的内部调用超类型构造函数,利用apply()或call(),可以在将来创建对象实例的时候执行构造函数. 123456789101112131415function SuperType(name)&#123; this.name = name; this.property = true; this.sayName = function()&#123; console.log(this.name); &#125; &#125;function SubType()&#123; //继承了SuperType SuperType.call(this,\"lz\"); //为了确保SuperType构造函数不会重写子类型的属性.可以在调用超类型构造函数后，再添加应该在子类型中定义的属性 this.age = 22;&#125;var instance = new SubType();console.log(instance); 不足 方法都在构造函数中定义，因此函数复用就无从谈起了. 在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式. 组合继承 类比使用构造函数模式定义类型时的解决方法（组合构造函数模式与原型模式,继承时的解决方法也类似),即组合原型链继承和借用构造函数,属性由借用构造函数的方式继承,方法由原型链继承. 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name = name; this.colors = [\"red\",\"green\"]; &#125; SuperType.prototype.sayName = function () &#123; console.log(this.name); &#125;; function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age = age; &#125; //继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () &#123; console.log(this.age); &#125;; var instance1 = new SubType(\"lz\", 18); instance1.colors.push(\"black\"); var instance2 = new SubType('zl',81); instance2.colors.push('blue'); console.log(instance1.colors); console.log(instance2.colors); 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点 原型式继承 原型式继承没有使用严格意义上的构造函数,而是借助原型,基于已有的对象创建新对象,同时还无需创建自定义类型,于是,可以借助这个函数: 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; 在 object()函数内部,先创建了一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.从本质上讲, object()对传入其中的对象执行了一次浅复制. 12345678910111213var person = &#123; name: \"LZ\", friends: [\"aa\",\"bb\",\"cc\"] &#125;; var lz = object(person); var zl = object(person); lz.friends.push(\"zz\"); lz.name = \"lz\"; zl.friends.push(\"ee\"); zl.name = \"zl\"; console.log(person.friends);//[\"aa\", \"bb\", \"cc\", \"zz\", \"ee\"] console.log(person.name);//LZ console.log(lz); //F &#123;friends: Array[1], name: \"lz\"&#125; 如果想使用这种原型式继承,必须先有一个基础对象.可以把它传递给object(),然后根据具体得到的对象加以修改即可. 在这个例子中,把person传入object函数,然后该函数返回一个新对象,这个新对象将 person 作为原型,所以它的原型中就包含一个基本类型值属性和一个引用类型值属性.这意味着 person.friends 不仅属于 person 所有,而且也会被 anotherPerson 以及 yetAnotherPerson 共享.实际上,这就相当于又创建了 person 对象的两个副本. ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承,这个方法接收两个参数,在传入一个参数的情况下, Object.create()与 object()方法的行为相同. Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如: 123456var anotherPerson = Object.create(person, &#123;name: &#123;value: \"Greg\"&#125;&#125;);alert(anotherPerson.name); //\"Greg\" 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象. 12345678910111213function createAnother(origin)&#123; var clone = Object.create(origin); clone.sayHi = function () &#123; alert('Hi'); &#125;; return clone; &#125; var person = &#123; name: \"LZ\", friends: [\"aa\",\"bb\",\"cc\"] &#125;; var lz = createAnother(person); lz.sayHi(); 这个例子中的代码基于 person 返回了一个新对象——anotherPerson.新对象不仅具有 person的所有属性和方法，而且还有自己的 sayHi()方法 使用寄生式继承来为对象添加函数,会由于不能做到函数复用而降低效率.这一点与构造函数模式类似. 寄生组合式继承使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型12345function inheritPrototype(subType,supType) &#123; var prototype = Object.create(supType.prototype); prototype.constructor = subType; subType.prototype = prototype; &#125; 有了上面这个函数,就可以不必为了指定子类型的原型而调用超类型的构造函数.而后通过借用构造函数实现设置属性.123456789101112131415161718function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"]; &#125; SuperType.prototype.sayName = function () &#123; console.log(this.name); &#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(SubType,SuperType); SubType.prototype.sayAge = function () &#123; console.log(this.age); &#125;; var lz = new SubType(\"lz\",18); console.log(lz);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"根据URL编码获取汉字真正的Unicode编码","slug":"根据URL编码获取汉字真正的Unicode编码","date":"2015-06-19T15:12:41.000Z","updated":"2017-05-06T11:04:12.329Z","comments":true,"path":"2015/06/19/根据URL编码获取汉字真正的Unicode编码/","link":"","permalink":"http://lizhi.trade/2015/06/19/根据URL编码获取汉字真正的Unicode编码/","excerpt":"","text":"一般情况下,网址路径的编码，用的是utf-8编码 在js中,如果我们想获取一个汉字或者字符的utf-8编码,可以使用encodeURIComponent encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。 然后求出这个编码的十进制表示,进而求出二进制表示 每八位分割成一个字节,根据utf-8编码规则取出源码 Unicode符号范围(十六进制) UTF-8编码方式（二进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 取出的源码等于汉字的Unicode编码(汉字的Unicode可以通过charCodeAt获取) 1234567var me = '我';var charCode = me.charCodeAt(0); //25105var utf = encodeURIComponent('我').replace(/%/g,''); //E68891var dec = parseInt(utf,16); //15108241var bin = dec.toString(2); //111001101000100010010001//111001101000100010010001 =&gt; 11100110 10001000 10010001parseInt('0110001000010001',2) === charCode //true","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://lizhi.trade/tags/网络/"}]},{"title":"BFC布局-学习总结","slug":"BFC布局-学习总结","date":"2015-05-20T13:38:49.000Z","updated":"2017-05-06T11:01:50.147Z","comments":true,"path":"2015/05/20/BFC布局-学习总结/","link":"","permalink":"http://lizhi.trade/2015/05/20/BFC布局-学习总结/","excerpt":"","text":"一. w3c规范中的BFC定义：“浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 也就是说BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响）。并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 由这段定义，我们可以得出： 1. 哪些元素会生成BFC： 根元素(整个页面就是一个大的BFC)； float为 left | right； overflow为 hidden | auto | scroll； display为 inline-block | table-cell | table-caption | flex | inline-flex； position为 absolute | fixed；2. BFC的布局规则： 每一个BFC盒子会在垂直方向一个接一个地排列； 两个BFC盒子之间的垂直的间隙是由他们的margin 值所决定的。属于同一个BFC的两个相邻盒子的垂直方向的margin会重叠； 每一个BFC盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）； 4.计算BFC的高度时，浮动元素也参与计算； 不与外部浮动元素重叠； BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响；二. BFC的应用实例 1. 自适应两栏布局2. 清除内部浮动3. 防止垂直margin重叠在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值； 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值； 两个外边距一正一负时，折叠结果是两者的相加的和； 产生折叠的必备条件： margin必须是邻接的，没有padding和border将他们分隔开； 必须是处于常规文档流（非float和绝对定位）的块级元素，并且处于同一个BFC当中； 产生折叠的常见情况： 元素的margin-top与其第一个常规文档流的子元素的margin-top； 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top； height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom； 高度为0且不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom； 浮动和绝对定位不与任何元素产生 margin 折叠：原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠； 因此可以通过使元素成为BFC而避免margin折叠。BFC提供了一个独立布局的环境，每个BFC都遵守同一套布局规则。例如，在同一个BFC内，盒子会一个挨着一个的排，相邻盒子的间距是由margin决定且垂直方向的margin会重叠。而float和clear float也只对同一个BFC内的元素有效； 总结其实以上的几个例子都体现了BFC布局规则第六条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响。因此， 当BFC外部存在浮动时，外部元素不会影响BFC内部的布局，BFC会通过变窄，而不与浮动有重叠；同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度和margin值，因此可以避免margin重叠和闭合浮动。","categories":[],"tags":[{"name":"布局","slug":"布局","permalink":"http://lizhi.trade/tags/布局/"}]},{"title":"跨域","slug":"跨域","date":"2015-05-15T14:23:11.000Z","updated":"2017-05-06T11:04:34.776Z","comments":true,"path":"2015/05/15/跨域/","link":"","permalink":"http://lizhi.trade/2015/05/15/跨域/","excerpt":"概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 出于安全考虑，HTML的同源策略不允许JavaScript进行跨域操作，但是随着Web App的功能越来越强，对于跨域的需求也是与日俱增。 跨域大概分为两种： 第一种是xhr不能访问不同源的文档 第二种是不同window之间不能进行交互操作 跨域通信的方法大致可以分为两类 第一种是Hack，例如通过title，navigation等对象传递信息，最典型的就是JSONP。 第二类是HTML5支持，一个是Access-Control-Allow-Origin响应头，一个是window.postMessage。","text":"概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 出于安全考虑，HTML的同源策略不允许JavaScript进行跨域操作，但是随着Web App的功能越来越强，对于跨域的需求也是与日俱增。 跨域大概分为两种： 第一种是xhr不能访问不同源的文档 第二种是不同window之间不能进行交互操作 跨域通信的方法大致可以分为两类 第一种是Hack，例如通过title，navigation等对象传递信息，最典型的就是JSONP。 第二类是HTML5支持，一个是Access-Control-Allow-Origin响应头，一个是window.postMessage。 一.设置 document.domain document.domain:获取/设置当前文档的原始域部分, 用于 同源策略. 在根域范围内，Mozilla允许你把domain属性的值设置为它的上一级域。例如，在 developer.mozilla.org 域内，可以把domain设置为 “mozilla.org” 但不能设置为 “mozilla.com” 或者”org”。 原理：相同主域名不同子域名下的页面可以设置document.domain利用他的特性让他们同域 限制： 同于document提供的是页面之间的相互操作，所以需要载入iframe页面； 只适用于父子window之间的通信，不能用于xhr； 只能在主域相同且子域不同的情况下使用。 举个栗子：在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。 12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.a.com/b.html';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(\"h1\")[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.html： 1document.domain = 'a.com'; 二：有src的标签 原理：所有具有src属性的html标签都是可以跨域的，比如img和script 限制：需要创建一个DOM对象，而且只能用于get方法 代表：JSONP 浏览器对XHR做了同源策略，但并没有将这种方式延续到script上（其实还有iframe，img等），从而可以利用动态script标签技术来做到跨域请求的作用 JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 缺点：只能通过GET方式请求，一方面是参数长度有限制，二是安全性比较差； 需要服务器端的页面进行相应的配合的。 123456&lt;script type=\"text/javascript\"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src=\"http://example.com/data.php?callback=dosomething\"&gt;&lt;/script&gt; js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 三：window.name window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置 优点： 利用了浏览器的特性来做到不同域之间的数据传递 不需要前后端配合 限制： 安全性不高，当前页面的所有window都可以修改 不同浏览器对于window.name的大小有限制 传递数据只能传递字符串 四：navigation对象 原理：iframe之间是共享navigator对象的，用它来传递信息 限制：只限于ie6/7 五：跨域资源共享（CORS） 原理： cors是一种通过设置前后端http header配置Access-Control-Allow-Origin来进行跨域的一种方式 限制： 浏览器需要支持HTML5，可以支持POST，PUT等方法 HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题比如我们要从http://a.com访问http://b.com我们可以直接在b.com的服务器中设置相应字段 12Access-Control-Allow-Origin: * # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com # 只允许特定域名访问 六：window.postMessage 原理： HTML5允许窗口之间发送消息 限制： 浏览器需要支持HTML5，获取窗口句柄后才能相互通信 12345678// URL: http://a.com/foovar win = window.open('http://b.com/bar');win.postMessage('Hello, bar!', 'http://b.com'); // URL: http://b.com/barwindow.addEventListener('message',function(event) &#123; console.log(event.data);&#125;);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]}]}