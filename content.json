{"meta":{"title":"ilz Blog","subtitle":null,"description":"李智的个人博客","author":"李智","url":"http://lizhi.trade"},"pages":[{"title":"categories","date":"2017-02-22T08:58:12.000Z","updated":"2017-02-22T08:58:29.119Z","comments":true,"path":"categories/index.html","permalink":"http://lizhi.trade/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-22T08:56:55.000Z","updated":"2017-02-22T08:57:42.748Z","comments":true,"path":"tags/index.html","permalink":"http://lizhi.trade/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"根据URL编码获取汉字真正的Unicode编码","slug":"根据URL编码获取汉字真正的Unicode编码","date":"2017-03-19T08:12:41.000Z","updated":"2017-03-19T11:25:34.748Z","comments":true,"path":"2017/03/19/根据URL编码获取汉字真正的Unicode编码/","link":"","permalink":"http://lizhi.trade/2017/03/19/根据URL编码获取汉字真正的Unicode编码/","excerpt":"","text":"一般情况下,网址路径的编码，用的是utf-8编码 在js中,如果我们想获取一个汉字或者字符的utf-8编码,可以使用encodeURIComponent encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。 然后求出这个编码的十进制表示,进而求出二进制表示 每八位分割成一个字节,根据utf-8编码规则取出源码 Unicode符号范围(十六进制) UTF-8编码方式（二进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 取出的源码等于汉字的Unicode编码(汉字的Unicode可以通过charCodeAt获取) 1234567var me = '我';var charCode = me.charCodeAt(0); //25105var utf = encodeURIComponent('我').replace(/%/g,''); //E68891var dec = parseInt(utf,16); //15108241var bin = dec.toString(2); //111001101000100010010001//111001101000100010010001 =&gt; 11100110 10001000 10010001parseInt('0110001000010001',2) === charCode //true","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://lizhi.trade/tags/网络/"}]},{"title":"JavaScript冷门知识点","slug":"JavaScript冷门知识点","date":"2017-03-13T07:05:38.000Z","updated":"2017-03-14T03:22:38.385Z","comments":true,"path":"2017/03/13/JavaScript冷门知识点/","link":"","permalink":"http://lizhi.trade/2017/03/13/JavaScript冷门知识点/","excerpt":"","text":"parseInt 可以接收两个参数 string, radix(基数)第二个参数表示以几进制来表示第一个参数值,该值介于 2 ~ 36 之间。如果是0,则忽略此值。 例: 123parseInt('1', 0); =&gt; 1parseInt('2', 1); =&gt; NaNparseInt('3', 2); =&gt; NaN 在JS中,能正确计算且不失精度的最大整数是Math.pow(2, 53) == 9007199254740992,最大值加一还是最大值例,如下循环不会停止1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); JS中允许存在有空隙的数组,称之为稀疏数组例: 1234567var arr = [1,2,3];arr[100]=1;console.log(10 in arr);console.log(arr.length);arr.forEach(function(x)&#123; console.log(x);&#125;); 输出为: 123false1011 2 3 1 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接.例: 12345'5' + 3 === '53'5 + '3' === '53'5 - '3' === 2'5' - 3 === 2'5' - '3' === 2 JS中1.1, 1., .1 都是合法的数字例: 1233.toString() =&gt; error3..toString() =&gt; '3'3...toString() =&gt; error 数组在比较大小的时候按照值的顺序比较例: 1234567var a = [1, 2, 3], b = [1, 2, 4], c = [2]a &gt; b =&gt; falsea &lt; b =&gt; truea &gt; c =&gt; falsea &lt; c =&gt; true function的 length 属性就是函数的参数个数12Function.length == 1 //(奇葩)new Function().length == 0 Math.min VS Math.max1234Math.min() == InfinityMath.max() == -Infinity//由于这两个奇葩结果,故:Math.min() &gt; Math.max() == true 函数里的参数已经声明了例: 123456789101112131415function foo(a) &#123; var a; return a;&#125;function bar(a) &#123; var a = 'bye'; return a;&#125;//a作为参数其实已经声明了,故第一个函数就等价于var a = 'hello';var a;//第二个函数就等价于var a = 'hello';var a = 'bye'[foo('hello'), bar('hello')] =&gt; ['hello', 'bye'] 原型对象 Object.prototype =&gt; {} Array.prototype =&gt; [] Function.prototype =&gt; function(){} 更简洁的交换两个值: a= [b, b=a][0];","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"HTTP","slug":"HTTP","date":"2017-03-01T06:39:47.000Z","updated":"2017-03-01T07:25:39.714Z","comments":true,"path":"2017/03/01/HTTP/","link":"","permalink":"http://lizhi.trade/2017/03/01/HTTP/","excerpt":"","text":"HTTP协议简介当我们在浏览器地址栏输入lizhi.trade/index.html时,浏览器会先查找和lizhi.trade相关联的服务器地址,然后尝试连接80端口建立TCP连接,其中80端口是HTTP的默认通信端口.如果服务器接收了该请求,浏览器就会默认发送如下内容. GET /index.html HTTP/1.1Host: lizhi.tradeUser-Agent: Your brower’s name 然后服务器后返回如下响应 HTTP/1.1 200 OKContent-Length: 85214Content-Type: text/htmlLast-Modified: Web, 08 Apr2088 10:10:10 GMT &lt;!document html&gt;….. 浏览器会去除响应行的空行,并将剩下部分作为HTML文档展示","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://lizhi.trade/tags/网络/"}]},{"title":"JavaScript中实现继承的各种姿势","slug":"JavaScript中实现继承的各种姿势","date":"2017-02-21T10:57:53.000Z","updated":"2017-02-23T13:44:11.617Z","comments":true,"path":"2017/02/21/JavaScript中实现继承的各种姿势/","link":"","permalink":"http://lizhi.trade/2017/02/21/JavaScript中实现继承的各种姿势/","excerpt":"","text":"JavaScript 的继承是实现继承,而没有 Java 中的接口继承.这是因为JavaScript 中函数没有签名,而实现继承依靠的是原型链来实现的. 原型链继承 可以利用原型让一个引用类型继承另一个引用类型的属性和方法;由于每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针,而实例都包含一个指向原型对象的指针. 123456789101112function SuperType() &#123; this.type = 'super';&#125;SuperType.prototype.getType() &#123; return this.type;&#125;function SubType() &#123; this.type = 'sub';&#125;SubType.prototype = new SuperType();var instance = new SubType();console.log(instance.getType()); // \"sub\" 注意: 子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法.但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后. 在通过原型链实现继承时,不能使用对象字面量创建原型方法.因为这样做就会重写原型链. 不足: 在通过原型链实现继承时,原型实际上会变成另一个类型的实例.于是,原先的实例属性,也就成了现在的原型属性.而包含引用类型值的原型属性会被所有实例共享. 没有办法在不影响所有对象实例的情况下,给超类型的构造函数传递参数. 借用构造函数 在子类型构造函数的内部调用超类型构造函数,利用apply()或call(),可以在将来创建对象实例的时候执行构造函数. 123456789101112131415function SuperType(name)&#123; this.name = name; this.property = true; this.sayName = function()&#123; console.log(this.name); &#125; &#125;function SubType()&#123; //继承了SuperType SuperType.call(this,\"lz\"); //为了确保SuperType构造函数不会重写子类型的属性.可以在调用超类型构造函数后，再添加应该在子类型中定义的属性 this.age = 22;&#125;var instance = new SubType();console.log(instance); 不足 方法都在构造函数中定义，因此函数复用就无从谈起了. 在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式. 组合继承 类比使用构造函数模式定义类型时的解决方法（组合构造函数模式与原型模式,继承时的解决方法也类似),即组合原型链继承和借用构造函数,属性由借用构造函数的方式继承,方法由原型链继承. 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name = name; this.colors = [\"red\",\"green\"]; &#125; SuperType.prototype.sayName = function () &#123; console.log(this.name); &#125;; function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age = age; &#125; //继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () &#123; console.log(this.age); &#125;; var instance1 = new SubType(\"lz\", 18); instance1.colors.push(\"black\"); var instance2 = new SubType('zl',81); instance2.colors.push('blue'); console.log(instance1.colors); console.log(instance2.colors); 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点 原型式继承 原型式继承没有使用严格意义上的构造函数,而是借助原型,基于已有的对象创建新对象,同时还无需创建自定义类型,于是,可以借助这个函数: 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; 在 object()函数内部,先创建了一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.从本质上讲, object()对传入其中的对象执行了一次浅复制. 12345678910111213var person = &#123; name: \"LZ\", friends: [\"aa\",\"bb\",\"cc\"] &#125;; var lz = object(person); var zl = object(person); lz.friends.push(\"zz\"); lz.name = \"lz\"; zl.friends.push(\"ee\"); zl.name = \"zl\"; console.log(person.friends);//[\"aa\", \"bb\", \"cc\", \"zz\", \"ee\"] console.log(person.name);//LZ console.log(lz); //F &#123;friends: Array[1], name: \"lz\"&#125; 如果想使用这种原型式继承,必须先有一个基础对象.可以把它传递给object(),然后根据具体得到的对象加以修改即可. 在这个例子中,把person传入object函数,然后该函数返回一个新对象,这个新对象将 person 作为原型,所以它的原型中就包含一个基本类型值属性和一个引用类型值属性.这意味着 person.friends 不仅属于 person 所有,而且也会被 anotherPerson 以及 yetAnotherPerson 共享.实际上,这就相当于又创建了 person 对象的两个副本. ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承,这个方法接收两个参数,在传入一个参数的情况下, Object.create()与 object()方法的行为相同. Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如: 123456var anotherPerson = Object.create(person, &#123;name: &#123;value: \"Greg\"&#125;&#125;);alert(anotherPerson.name); //\"Greg\" 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象. 12345678910111213function createAnother(origin)&#123; var clone = Object.create(origin); clone.sayHi = function () &#123; alert('Hi'); &#125;; return clone; &#125; var person = &#123; name: \"LZ\", friends: [\"aa\",\"bb\",\"cc\"] &#125;; var lz = createAnother(person); lz.sayHi(); 这个例子中的代码基于 person 返回了一个新对象——anotherPerson.新对象不仅具有 person的所有属性和方法，而且还有自己的 sayHi()方法 使用寄生式继承来为对象添加函数,会由于不能做到函数复用而降低效率.这一点与构造函数模式类似. 寄生组合式继承使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型12345function inheritPrototype(subType,supType) &#123; var prototype = Object.create(supType.prototype); prototype.constructor = subType; subType.prototype = prototype; &#125; 有了上面这个函数,就可以不必为了指定子类型的原型而调用超类型的构造函数.而后通过借用构造函数实现设置属性.123456789101112131415161718function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"]; &#125; SuperType.prototype.sayName = function () &#123; console.log(this.name); &#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(SubType,SuperType); SubType.prototype.sayAge = function () &#123; console.log(this.age); &#125;; var lz = new SubType(\"lz\",18); console.log(lz);","categories":[{"name":"学习总结","slug":"学习总结","permalink":"http://lizhi.trade/categories/学习总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizhi.trade/tags/JavaScript/"}]},{"title":"BFC布局-学习总结","slug":"BFC布局-学习总结","date":"2017-02-20T13:38:49.000Z","updated":"2017-02-28T02:18:42.888Z","comments":true,"path":"2017/02/20/BFC布局-学习总结/","link":"","permalink":"http://lizhi.trade/2017/02/20/BFC布局-学习总结/","excerpt":"","text":"一. w3c规范中的BFC定义：“浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 也就是说BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响）。并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 由这段定义，我们可以得出： 1. 哪些元素会生成BFC： 根元素(整个页面就是一个大的BFC)； float为 left | right； overflow为 hidden | auto | scroll； display为 inline-block | table-cell | table-caption | flex | inline-flex； position为 absolute | fixed；2. BFC的布局规则： 每一个BFC盒子会在垂直方向一个接一个地排列； 两个BFC盒子之间的垂直的间隙是由他们的margin 值所决定的。属于同一个BFC的两个相邻盒子的垂直方向的margin会重叠； 每一个BFC盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）； 4.计算BFC的高度时，浮动元素也参与计算； 不与外部浮动元素重叠； BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响；二. BFC的应用实例 1. 自适应两栏布局2. 清除内部浮动3. 防止垂直margin重叠在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值； 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值； 两个外边距一正一负时，折叠结果是两者的相加的和； 产生折叠的必备条件： margin必须是邻接的，没有padding和border将他们分隔开； 必须是处于常规文档流（非float和绝对定位）的块级元素，并且处于同一个BFC当中； 产生折叠的常见情况： 元素的margin-top与其第一个常规文档流的子元素的margin-top； 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top； height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom； 高度为0且不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom； 浮动和绝对定位不与任何元素产生 margin 折叠：原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠； 因此可以通过使元素成为BFC而避免margin折叠。BFC提供了一个独立布局的环境，每个BFC都遵守同一套布局规则。例如，在同一个BFC内，盒子会一个挨着一个的排，相邻盒子的间距是由margin决定且垂直方向的margin会重叠。而float和clear float也只对同一个BFC内的元素有效； 总结其实以上的几个例子都体现了BFC布局规则第六条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素与容器外部元素不会相互影响。因此， 当BFC外部存在浮动时，外部元素不会影响BFC内部的布局，BFC会通过变窄，而不与浮动有重叠；同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度和margin值，因此可以避免margin重叠和闭合浮动。","categories":[{"name":"学习总结","slug":"学习总结","permalink":"http://lizhi.trade/categories/学习总结/"}],"tags":[{"name":"布局","slug":"布局","permalink":"http://lizhi.trade/tags/布局/"}]}]}